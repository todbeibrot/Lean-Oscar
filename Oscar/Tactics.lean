import Mathlib
import Mrdi.Basic
import Mrdi.Stream
import Mrdi.ToExpr
import Oscar.Server
import Mrdi.ToMrdiNoncomputable
import Mrdi.ListToSet
import Std
import Qq
import Mathlib.Tactic.ToExpr
import Lean.Meta.Tactic.Intro

namespace Mrdi.Tactic

open Qq Lean Elab Tactic Meta IO.MrdiFile Expr Server

/-- `load_file file` loads from mrdi-files/file.mrdi -/
syntax "load_file " term : tactic
elab_rules : tactic
  | `(tactic| load_file $file) => do
    let fileE ← elabTerm file q(String)
    let goal ← getMainGoal
    goal.withContext do
      let α ← goal.getType
      let a ← IO.MrdiFile.loadMrdiFromFile α fileE (trace := False)
      goal.assign a


section Matrix_inverse

/-- Takes a matrix, returns the type of the elements and the dimensions -/
private def matrixType (u) (x : Q(Type $u)) : MetaM (Q(Type u) × Q(ℕ) × Q(ℕ)) := match x with
  | ~q(((Matrix (Fin ($m + 1)) (Fin ($n + 1)))) $α) => return (q($α), q($m) ,q($n))
  | _ => throwError "input didn't match expected type"

/-- Same as `matrix_inverse` with more details -/
def matrix_inverse' (A : Expr) (goal : MVarId) : TacticM Unit := do
  let tA ← inferType A
  let .sort u ← instantiateMVars (← whnf (← inferType tA)) | unreachable!
  let some v := u.dec | throwError "not a type{indentExpr tA}"
  let (α, m, n) ← matrixType ql(v) tA
  let A_mrdi : Mrdi ← Mrdi? A
  let inv_mrdi ← julia "matrix inverse" A_mrdi
  let inv : Q(Matrix (Fin ($m + 1)) (Fin ($n + 1)) $α) ← evalMrdi q(Matrix (Fin ($m + 1)) (Fin ($n + 1)) $α) inv_mrdi
  goal.assign inv
  return

def matrix_inverse (A : Expr) (goal : MVarId) : TacticM Unit := do
  let tA ← inferType A
  let .sort u ← instantiateMVars (← whnf (← inferType tA)) | unreachable!
  let some v := u.dec | throwError "not a type{indentExpr tA}"
  let (α, m, n) ← matrixType ql(v) tA
  let inv ← julia' "matrix inverse" A q(Matrix (Fin ($m + 1)) (Fin ($n + 1)) $α)
  goal.assign inv
  return

syntax "matrix_inverse " term : tactic
elab_rules : tactic
  | `(tactic| matrix_inverse $A) => do
    let A ← elabTerm A none
    let goal ← getMainGoal
    matrix_inverse A goal

end Matrix_inverse


section Permutation

def FreeGroup.reverseWord (g : FreeGroup α) [DecidableEq α] : FreeGroup α := .mk g.toWord.reverse

/-- A product of elements of a vector is in the Group generated by the elements of the vector.
    And so is the product defined by the lifting the word. -/
theorem FreeGroup_lift_word_mem_GroupClosure [Group α] {n : ℕ} (v : Vector α n) (word : FreeGroup (Fin n)) :
  let f : FreeGroup (Fin n) →* α := (FreeGroup.lift fun (i : Fin n) => Vector.get v i)
  f word ∈ Group.closure (List.toSet v.toList) := by
    have h (x : Fin n) : (FreeGroup.lift fun i => Vector.get v i) (pure x) = v.get x := FreeGroup.lift.of
    induction word using FreeGroup.induction_on with
      | C1 => apply Group.InClosure.one
      | Cp x =>
          apply Group.InClosure.basic
          simp [List.toSet_mem, h]
      | Ci x _ =>
          simp [h]
          apply Group.InClosure.inv
          apply Group.InClosure.basic
          simp [List.toSet_mem]
      | Cm x y hx hy =>
          simp [h] at *
          apply Group.InClosure.mul hx hy

-- TODO how can I use `Lean.Meta.replaceTargetEq` and get `eqProof` as a new goal without writing a new definition for it?
/--
  Convert the given goal `Ctx |- target` into `Ctx |- targetNew` and an equality proof `eqProof : target = targetNew`.
-/
def replaceTargetEq (mvarId : MVarId) (targetNew : Expr) : MetaM (MVarId × MVarId) :=
  mvarId.withContext do
    mvarId.checkNotAssigned `replaceTarget
    let target   ← mvarId.getType
    let eq       ← mkEq target targetNew
    let mvarEq   ← mkFreshExprSyntheticOpaqueMVar eq `eqProof
    let tag      ← mvarId.getTag
    let mvarNew  ← mkFreshExprSyntheticOpaqueMVar targetNew tag
    let u        ← getLevel target
    let val  := mkAppN (Lean.mkConst `Eq.mpr [u]) #[target, targetNew, mvarEq, mvarNew]
    mvarId.assign val
    return (mvarNew.mvarId!, mvarEq.mvarId!)

def PermsToList (u) (α : Q(Type $u)) (g : Q($α)) (gens : Q(Set $α)) : MetaM $ Q(List $α) × Q(List $α) := do
  let gens : Q(List $α) ← Set.toList gens
  return (q($g :: $gens), q($gens))

/- Solves goals of type `x ∈ Group.closure {a, b, c, ...}` where `x`, `a`, `b`, `c`, ... are permutations -/
def perm_group_membership (goal : MVarId) : TacticM Unit := do
  let goal_type ← goal.getType
  let some (g_type, γ, mem_inst, g, closure_set) := app5? goal_type ``Membership.mem | throwError "not a goal of type g ∈ G"
  let .sort sort_v ← inferType γ | throwError "not a sort"
  let some v := sort_v.dec | throwError "not a type{indentExpr (.sort sort_v)}"
  have γ : Q(Type $v) := γ
  have closure_set : Q($γ) := closure_set
  let .sort sort_u ← inferType g_type | throwError "not a sort"
  let some u := sort_u.dec | throwError "not a type{indentExpr (.sort sort_u)}"
  have g_type : Q(Type $u) := g_type
  have g : Q($g_type) := g
  let some (_, inst, gens) :=  closure_set.app3? ``Group.closure | throwError "G is not a Group.closure"
  have _ : Q(Group $g_type) := inst
  let (g_and_gens, gens) ← PermsToList u g_type g gens
  let n : Q(ℕ) := q(List.length $gens)
  let gens_vector : Q(Vector $g_type $n) := q(⟨$gens, rfl⟩)
  let n' ← unsafe evalExpr ℕ q(ℕ) n
  have n : Q(ℕ) := toExpr n'
  let mrdi : Mrdi ← IO.MrdiFile.Mrdi? g_and_gens
  -- For whatever reason the word coming back is in reversed order. I can't figure out why.
  -- This might be cause we ignore the epimorphism.
  let word_mrdi : Mrdi ← julia "perm group membership" mrdi
  let word : Q(FreeGroup (Fin $n)) ← evalMrdi q(FreeGroup (Fin $n)) word_mrdi
  let word : Q(Expr) := q(toExpr $word)
  let word ← unsafe evalExpr Expr q(Expr) word
  have word : Q(FreeGroup (Fin (List.length $gens))) := word
  let _ ← synthInstanceQ q(Inhabited $g_type)
  let prod := q(FreeGroup.lift (fun (x : Fin (List.length $gens)) => Vector.get $gens_vector x) (FreeGroup.reverseWord $word))
  have _ : Q(Membership $g_type $γ) := mem_inst
  let targetNew := q($prod ∈ $closure_set)
  let (new_goal, eq_goal) ← replaceTargetEq goal targetNew
  let eq_goal ← eq_goal.withContext do
    let tacticCode ← `(tactic| congr; ext x; fin_cases x; any_goals rfl)
    let (eq_goal, _) ← Elab.runTactic eq_goal tacticCode
    return eq_goal
  let new_goal ← new_goal.withContext do
    let tacticCode ← `(tactic| apply FreeGroup_lift_word_mem_GroupClosure)
    let (new_goal, _) ← Elab.runTactic new_goal tacticCode
    return new_goal
  replaceMainGoal (new_goal ++ eq_goal)

/- Solves goals of type `x ∈ Group.closure {a, b, c, ...}` where `x`, `a`, `b`, `c`, ... are permutations -/
syntax "perm_group_membership " : tactic
elab_rules : tactic
  | `(tactic| perm_group_membership) => do
    let goal ← getMainGoal
    perm_group_membership goal

end Permutation


section KBMAG

def _root_.Group.isTrivial (G : Type) [Group G] := ∀x : G, x = 1

theorem doubleton_eq (x y : α) : [x, y] = [x] ++ [y] := rfl

theorem mk_not_right {α : Type u} {x : α} {b : Bool} :
    FreeGroup.mk [(x, b), (x, !b)] = 1 := by
  rw [doubleton_eq, ← FreeGroup.mul_mk, ← inv_inv (FreeGroup.mk [(x, !_)]), mul_inv_eq_one,
    FreeGroup.inv_mk, FreeGroup.invRev]
  simp

theorem aux {α : Type u} (x : α) :
    FreeGroup.mk [(x, true), (x, false)] = 1 := by
  rw [← Bool.not_true]
  exact mk_not_right

theorem start_equations {α : Type u} (rels : Set (FreeGroup α)) (x : α) :
    (@QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk [(x, true), (x, false)])) = 1 := by
  simp [aux]

theorem start_equations_inv {α : Type u} (rels : Set (FreeGroup α)) (x : α) :
    (@QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk [(x, false), (x, true)])) = 1 := by
  rw [← Bool.not_false, mk_not_right, QuotientGroup.mk_one]

@[reducible]
def PresentedGroup.mk {α : Type u} (rels : Set (FreeGroup α)) (l : List (α × Bool)) :=
  @QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk l)

/-- The end of l₁ which is the same as the start of l₂. -/
def overlap [DecidableEq α] (l₁ l₂ : List α) : List α :=
let rec aux (l₁ l₂ : List α) :=
  match l₁, l₂ with
  | [], _ => []
  | _, [] => []
  | a :: as, b :: bs => if a = b then a :: aux as bs else []
aux l₁.reverse l₂

/-- l₁ but deleting the overlap with l₂. -/
def cut [DecidableEq α] (l₁ l₂ : List α) : List α :=
let rec aux (l₁ l₂ : List α) :=
  match l₁, l₂ with
  | [], _ => []
  | l, [] => l
  | a :: as, b :: bs => if a = b then aux as bs else a :: as
(aux l₁.reverse l₂).reverse

/-- l₂ but deleting the overlap with l₁. -/
def cut' [DecidableEq α] (l₁ l₂ : List α) : List α :=
let rec aux (l₁ l₂ : List α) :=
  match l₁, l₂ with
  | [], l => l
  | _, [] => []
  | a :: as, b :: bs => if a = b then aux as bs else b :: bs
aux l₁.reverse l₂

/-- New equations constructed by overlapping h1 and h2 -/
theorem eq {α : Type u} [DecidableEq α] {l₁ l₂ l₃ : List (α × Bool)} {rels : Set (FreeGroup α)}
  (h₁ : PresentedGroup.mk rels l₁ = PresentedGroup.mk rels l₂)
  (h₂ : PresentedGroup.mk rels l₃ = 1) :
    PresentedGroup.mk rels (cut l₂ l₃ ++ overlap l₂ l₃ ++ cut' l₁ l₃) = PresentedGroup.mk rels (cut l₁ l₃) := by
      sorry

/-- New equations constructed by overlapping h1 and h2 -/
theorem eq' {α : Type u} [DecidableEq α] {l₁ l₃ l₄ : List (α × Bool)} {rels : Set (FreeGroup α)}
  (h₁ : PresentedGroup.mk rels l₁ = 1)
  (h₂ : PresentedGroup.mk rels l₃ = PresentedGroup.mk rels l₄) :
    PresentedGroup.mk rels (cut l₁ l₃ ++ overlap l₁ l₄ ++ cut' l₁ l₄) = PresentedGroup.mk rels (cut' l₁ l₃) := by
      sorry

/-- The relations are in the kern -/
theorem lift_rels {α : Type u} {l : List (α × Bool)} {rels : Set (FreeGroup α)}
  (h : FreeGroup.mk l ∈ rels) :
    (@QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk l)) = 1 := by
      rw [QuotientGroup.eq_one_iff]
      exact Subgroup.subset_normalClosure h

/-- Cancels the first element if it is the same on both sides -/
theorem left_cancel_iff {α : Type u} {a : α × Bool} {l₁ l₂ : List (α × Bool)} {rels : Set (FreeGroup α)} :
      (@QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk (a :: l₁)) =
        @QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk (a :: l₂))) ↔
          ((@QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk l₁)) =
            (@QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk l₂))) := by
              rw [← List.singleton_append (l := l₁), ← FreeGroup.mul_mk, ← List.singleton_append (l := l₂), ← FreeGroup.mul_mk,
                    QuotientGroup.mk_mul, QuotientGroup.mk_mul]
              rw [mul_left_cancel_iff]

/-- Makes sure the simpler argument is on the left side of the equation -/
theorem maybe_symm {α : Type u} [DecidableEq α] {l₁ l₂ : List (α × Bool)} {rels : Set (FreeGroup α)}
  (_ : l₂.length < l₁.length) :
    PresentedGroup.mk rels l₁ = PresentedGroup.mk rels l₂ ↔ PresentedGroup.mk rels l₂ = PresentedGroup.mk rels l₁ := by
      constructor
      · intro h
        exact h.symm
      · intro h
        exact h.symm

theorem replace_all {α : Type u} [DecidableEq α] {l₁ l₂ : List (α × Bool)} {rels : Set (FreeGroup α)} {a b : α × Bool}
  (h : PresentedGroup.mk rels [a] = PresentedGroup.mk rels [b]) :
    PresentedGroup.mk rels l₁ = PresentedGroup.mk rels l₂ ↔ PresentedGroup.mk rels (List.map (fun x => if x = a then b else x) l₁) =
      PresentedGroup.mk rels (List.map (fun x => if x = a then b else x) l₂) := by
        sorry

theorem replace_all' {α : Type u} [DecidableEq α] {l₁ : List (α × Bool)} {rels : Set (FreeGroup α)} {a b : α × Bool}
  (h : PresentedGroup.mk rels [a] = PresentedGroup.mk rels [b]) :
    PresentedGroup.mk rels l₁ = 1 ↔ PresentedGroup.mk rels (List.map (fun x => if x = a then b else x) l₁) = 1 := by
        sorry

theorem replace_all'' {α : Type u} [DecidableEq α] {l₁ l₂ : List (α × Bool)} {rels : Set (FreeGroup α)} {a : α × Bool}
  (h : PresentedGroup.mk rels [a] = 1) :
    PresentedGroup.mk rels l₁ = PresentedGroup.mk rels l₂ ↔ PresentedGroup.mk rels (List.filter (fun x => x ≠ a) l₁) =
      PresentedGroup.mk rels (List.filter (fun x => x ≠ a) l₂) := by
        sorry

theorem replace_all''' {α : Type u} [DecidableEq α] {l₁ : List (α × Bool)} {rels : Set (FreeGroup α)} {a : α × Bool}
  (h : PresentedGroup.mk rels [a] = 1) :
    PresentedGroup.mk rels l₁ = 1 ↔ PresentedGroup.mk rels (List.filter (fun x => x ≠ a) l₁) = 1 := by
        sorry

def reverse {α : Type u} (rels : Set (FreeGroup α)) (l : List (α × Bool)) :=
    @QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk l.reverse)

theorem revert {α : Type u} {l₁ l₂ : List (α × Bool)} {rels : Set (FreeGroup α)} :
  reverse rels l₁.reverse =
    reverse rels l₂.reverse ↔
      (@QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk l₁)) =
        (@QuotientGroup.mk (FreeGroup α) _ (Subgroup.normalClosure rels) (FreeGroup.mk l₂)) := by
          simp [reverse]

theorem reverse_left_cancel_iff {α : Type u} {a : α × Bool} {l₁ l₂ : List (α × Bool)} {rels : Set (FreeGroup α)} :
  reverse rels (a :: l₁) = reverse rels (a :: l₂) ↔ reverse rels l₁ = reverse rels l₂ := by
    sorry

theorem FreeGroup.inv_self_word : FreeGroup.mk ((x, false) :: (x, true) :: l) =  FreeGroup.mk l := by sorry

theorem FreeGroup.self_inv_word : FreeGroup.mk ((x, true) :: (x, false) :: l) =  FreeGroup.mk l := by sorry

theorem PresentedGroup.induction_on {α : Type u_1} {rels : Set (FreeGroup α)} {C : PresentedGroup rels → Prop}
  (x : PresentedGroup rels) (H : ∀ z : α, C (PresentedGroup.of z)) :
    C x := by
      sorry --QuotientGroup.induction_on

private def fp_group_n {u} {α : Q(Type $u)} (_ : Q(List (FreeGroup $α))) :
  MetaM Q(ℕ) := do
    match q($α) with
    | ~q(Fin $n) => return q($n)
    | _ => throwError "not a Fin n"

private def fingroupType
  (u) (G : Q(Sort $u)) :
  MetaM Q(ℕ) := match q($G) with
    | ~q(PresentedGroup (List.toSet $rels)) => do
        let n ← fp_group_n q($rels)
        return n
    | _ => throwError "input didn't match expected type"

private def fpgroupRels (n : Q(ℕ))
  (u) (G : Q(Sort $u)) :
  MetaM Q(List (FreeGroup (Fin $n))) := match q($G) with
    | ~q(PresentedGroup (List.toSet $rels)) => do
        have rels : Q(List (FreeGroup (Fin $n))) := rels
        return rels
    | _ => throwError "input didn't match expected type"

open Lean.Parser.Tactic
open Lean.Syntax

def kbmag_equations (g : Expr) (goal : MVarId) : TacticM MVarId := do
  let mut goal := goal
  let ⟨u, G, g⟩ ← inferTypeQ g

  let n ← fingroupType u G
  let n' : ℕ ← unsafe evalExpr ℕ q(ℕ) n
  let rels ← fpgroupRels n u G
  let rels_stx ← Term.exprToSyntax rels

  let equationsE : Q(List $ ℕ × Bool × ℕ × ℕ × (FreeGroup (Fin $n)) × (FreeGroup (Fin $n))) ← julia' "kbmag" g q(List $ ℕ × Bool × ℕ × ℕ × (FreeGroup (Fin $n)) × (FreeGroup (Fin $n)))
  let equations ← unsafe evalExpr (List $ ℕ × Bool × ℕ × ℕ × (FreeGroup (Fin n')) × (FreeGroup (Fin n')))
    q(List $ ℕ × Bool × ℕ × ℕ × (FreeGroup (Fin $n)) × (FreeGroup (Fin $n))) equationsE

  let name (i : ℕ) := Name.str .anonymous s!"h{i}"
  let h (i : ℕ) := mkIdent (name i)

  -- start equations
  for i in List.range n' do
    goal ← goal.withContext do
      Term.synthesizeSyntheticMVars false
      let ident : Ident := h (2 * i + 1)
      let tacticCode ← `(tactic|
        have $ident := start_equations (List.toSet $rels_stx) $(quote i))
      let (new_goal, _) ← Elab.runTactic goal tacticCode
      replaceMainGoal new_goal
      return new_goal[0]!
    goal ← goal.withContext do
      Term.synthesizeSyntheticMVars false
      let ident : Ident := h (2 * i + 2)
      let tacticCode ← `(tactic|
        have $ident := start_equations_inv (List.toSet $rels_stx) $(quote i))
      let (new_goal, _) ← Elab.runTactic goal tacticCode
      replaceMainGoal new_goal
      return new_goal[0]!

  for i in List.range equations.length do
    let i' : Q(ℕ) := toExpr i
    let equationE : Q(FreeGroup (Fin «$n») × FreeGroup (Fin «$n»)) ← whnf q($equationsE[$i']!.2.2.2.2)
    let lhs : Q(FreeGroup (Fin «$n»)) := q($equationE.1)
    let lifted_lhs := q((QuotientGroup.mk (s := Subgroup.normalClosure (List.toSet «$rels»)) $lhs))
    let rhs : Q(FreeGroup (Fin «$n»)) := q($equationE.2)
    let lifted_rhs := q((QuotientGroup.mk (s := Subgroup.normalClosure (List.toSet «$rels»)) $rhs))
    let lifted_equation : Expr := q($lifted_lhs = $lifted_rhs)
    let ⟨equation_number, new_equation, overlap₁, overlap₂, _, _⟩ := equations[i]!
    if new_equation then do
      -- new equations
      goal ← goal.withContext do
        let ident : Ident := h equation_number
        let loc ← `(location| at $ident:term)

        let tacticCode ←  `(tactic|
          (try have $ident := (eq  $(h overlap₁) $(h overlap₂)));
          (try have $ident := (eq' $(h overlap₁) $(h overlap₂)));
          (try simp [PresentedGroup.mk, overlap, cut, cut', overlap.aux, cut.aux, cut'.aux, FreeGroup.invRev] $loc);
          (repeat
            (simp [*, -QuotientGroup.eq_one_iff] $loc);
            (try simp only [FreeGroup.self_inv_word, FreeGroup.inv_self_word] $loc);
            (try simp [FreeGroup.invRev, left_cancel_iff, -QuotientGroup.eq_one_iff] $loc);
            (try rw [← revert] $loc);
            (try simp [FreeGroup.invRev, reverse_left_cancel_iff, -QuotientGroup.eq_one_iff] $loc);
            (try simp [maybe_symm, reverse, -QuotientGroup.eq_one_iff, eq_comm (a := 1)] $loc));
          (try rw [eq_comm (a := 1)] $loc))
        let (new_goal, _) ← Elab.runTactic goal tacticCode
        replaceMainGoal new_goal

        let mut goal' := new_goal[0]!
        for j in List.range' 1 (equation_number - 2) do
          goal' ← goal'.withContext do
            let h_j : Ident := h j
            let loc_j ← `(location| at $h_j:term)
            let tacticCode ← `(tactic|
              (try rw [replace_all    $ident] $loc_j);
              (try rw [replace_all'   $ident] $loc_j);
              (try rw [replace_all''  $ident] $loc_j);
              (try rw [replace_all''' $ident] $loc_j);
              (try simp only [Fin.isValue, mk, ↓reduceIte, Prod.mk.injEq, zero_ne_one, and_self, List.map_cons,
                one_ne_zero, and_true, and_false, List.map_nil, List.filter_nil, List.filter_cons_of_pos,
                List.filter_cons_of_neg, ne_eq, decide_not, decide_False, Bool.not_false, Bool.not_true,
                not_false_eq_true] $loc_j);
              (try simp [-QuotientGroup.eq_one_iff] $loc_j))
            let (new_goal, _) ← Elab.runTactic goal' tacticCode
            replaceMainGoal new_goal
            return new_goal[0]!
        return goal'
      replaceMainGoal [goal]
    else do
      -- relations
      goal ← goal.withContext do
        Term.synthesizeSyntheticMVars false
        let lifted_equation ← instantiateMVars lifted_equation
        let mvarEq ← mkFreshExprSyntheticOpaqueMVar lifted_equation (name equation_number)
        let (_, goal') ← (← MVarId.assert goal (name equation_number) lifted_equation mvarEq).intro1P
        let new_goal := mvarEq.mvarId!
        let new_goal ← new_goal.withContext do
          let tacticCode ← `(tactic|
            apply eq_of_mul_inv_eq_one;
            apply lift_rels;
            try simp [List.toSet_mem, FreeGroup.invRev])
          let (new_goal, _) ← Elab.runTactic new_goal tacticCode
          return new_goal
        replaceMainGoal (goal' :: new_goal)
        return goal'
      goal ← goal.withContext do
        let ident : Ident := h equation_number
        let loc ← `(location| at $ident:term)
        let tacticCode ← `(tactic|
          try simp [FreeGroup.invRev, left_cancel_iff] $loc)
        let (new_goal, _) ← Elab.runTactic goal tacticCode
        replaceMainGoal new_goal
        return new_goal[0]!
  return goal

def finish_isTrivial (goal : MVarId) : TacticM Unit := do
  let x := mkIdent (Name.str .anonymous "x")
  let z := mkIdent (Name.str .anonymous "z")
  let tacticCode ← `(tactic|
    (intro $x:term);
    (apply PresentedGroup.induction_on $x);
    (intro $z:term);
    (unfold PresentedGroup.of FreeGroup.of);
    (fin_cases $z:term)
  )
  let (new_goals, _) ← Elab.runTactic goal tacticCode
  let mut all_goals := []
  for goal' in new_goals do
    let tacticCode ← `(tactic| simp[*])
    let (new_goals', _) ← Elab.runTactic goal' tacticCode
    all_goals := all_goals ++ new_goals'
  replaceMainGoal all_goals

def finish_equation (goal : MVarId) : TacticM Unit := do
  let tacticCode ← `(tactic| simp[*, PresentedGroup.of, FreeGroup.of])
  let (new_goals, _) ← Elab.runTactic goal tacticCode
  replaceMainGoal new_goals

def kbmag (g : Expr) (goal : MVarId) : TacticM Unit := do
  let t ← goal.getType
  let goal ← kbmag_equations g goal
  let some (_, _, _) := t.eq? | finish_isTrivial goal
  finish_equation goal

syntax "kbmag " term : tactic
elab_rules : tactic
  | `(tactic| kbmag $g) => do
    let g ← elabTerm g none
    let goal ← getMainGoal
    kbmag g goal

end KBMAG

end Mrdi.Tactic
